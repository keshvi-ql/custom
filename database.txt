git clone https://github.com/keshvi-ql/custom.git
git status
git add .
git commit -m "COMMIT_MESSAGE"
git push -u origin main

username = keshvi-ql
git = keshvi.g@queueloopsolutions.com
pass = Keshvi@106
----------------------------
https://chatgpt.com/c/6836b33d-1c18-8002-812f-dccedd1e6bfc

Database Access and ORM (Object-Relational Mapping) provide a structured and secure way to interact with your database using PHP objects rather than writing raw SQL queries.
database is done with two primary object 
   ->repositories or table Object 
   ->Entities 

=======================================
Database Basics
The easiest way to create a database connection is using a DSN string
Running Select Statements = run Select Statement
Running Insert Statements = insert recode
Running Update Statements = update recode
Running Delete Statements = delete the recode
Configuration = create own Configuration 

‚úÖ Basic Required Settings:
| Key         | What It Means                                                            |
| ----------- | ------------------------------------------------------------------------ |
| `className` | The core class handling database connections (default is fine).          |
| `driver`    | The database type you're using. Examples: `Mysql`, `Sqlite`, `Postgres`. |
| `host`      | Hostname where the DB server is running. Usually `localhost`.            |
| `username`  | Your DB username. Example: `root`.                                       |
| `password`  | The password for that username.                                          |
| `database`  | The name of the database you are connecting to.                          |

üéõ Optional but Useful Settings:
| Key           | Use Case                                                                                    |
| ------------- | ------------------------------------------------------------------------------------------- |
| `port`        | Custom DB port. Default is 3306 for MySQL. Set it only if you're using a non-standard port. |
| `encoding`    | Character set used. Example: `'utf8mb4'` (good for emojis).                                 |
| `timezone`    | Timezone to use for DB timestamps. Example: `'UTC'`.                                        |
| `persistent`  | Keeps connection open between requests. Good for performance, but not supported on MSSQL.   |
| `schema`      | For PostgreSQL: sets the schema to use.                                                     |
| `unix_socket` | Used instead of host if connecting via a Unix socket (MySQL/Postgres on some servers).      |

üîí SSL Security Options (MySQL Only):
| Key        | Use For                      |
| ---------- | ---------------------------- |
| `ssl_key`  | Path to SSL key file         |
| `ssl_cert` | Path to SSL certificate file |
| `ssl_ca`   | Path to CA certificate file  |

‚öôÔ∏è Other Helpful Settings:
| Key                | Description                                                               |
| ------------------ | ------------------------------------------------------------------------- |
| `init`             | Run SQL when connection starts. Example: `['SET time_zone = "+00:00"']`.  |
| `log`              | If `true`, logs all SQL queries (great for debugging).                    |
| `quoteIdentifiers` | Use this if you use special characters or reserved words in column names. |
| `flags`            | Extra PDO options. Mostly used for advanced configurations.               |
| `cacheMetadata`    | If `true`, speeds up performance by caching table metadata. Recommended!  |

üî∏ SQLite-Specific Settings (Ignore if using MySQL/PostgreSQL):
| Key     | What It Does                             |
| ------- | ---------------------------------------- |
| `mask`  | Sets permissions for created SQLite file |
| `cache` | Sets SQLite caching behavior             |
| `mode`  | Sets access mode for SQLite (read/write) |

üß† Naming Conventions (VERY IMPORTANT)
| Item          | Convention                                                 |
| ------------- | ---------------------------------------------------------- |
| Table names   | lowercase, plural, snake\_case ‚Üí `blog_posts`              |
| Table classes | PascalCase, ends with `Table` ‚Üí `BlogPostsTable`           |
| Controller    | PascalCase, ends with `Controller` ‚Üí `BlogPostsController` |

==============================
Read and Write Connections refer to a database scaling technique that allows you to separate database read and write operations across different servers.

Managing Connections refers to the way you configure, retrieve, and use database connections in your application

Accessing Connections means retrieving a configured database connection to interact directly with the database‚Äîeither to run raw SQL, perform inserts/updates/deletes, or execute custom queries outside of the ORM.

Creating Connections at Runtime means defining a new database connection dynamically (in code) rather than in the config/app.php or app_local.php configuration files.

Data Types system provides a way to abstract and standardize how different databases handle various column types
| Abstract Type    | Maps To (DB Equivalent)                              | Notes                           |
| ---------------- | ---------------------------------------------------- | ------------------------------- |
| `string`         | `VARCHAR`, or `NVARCHAR` in SQL Server               | Regular text                    |
| `char`           | `CHAR` or `NCHAR`                                    | Fixed-length text               |
| `text`           | `TEXT`, `CLOB`, etc.                                 | For long text                   |
| `uuid`           | `CHAR(36)` if native UUID not available              | Universally Unique ID           |
| `binaryuuid`     | `BINARY(16)` or native UUID                          | Compressed UUID                 |
| `nativeuuid`     | `UUID` for MariaDB/MySQL; alias for `uuid` otherwise | For native UUID support         |
| `integer`        | `INT`, `INTEGER`                                     | Whole numbers                   |
| `smallinteger`   | `SMALLINT`                                           | Smaller whole numbers           |
| `tinyinteger`    | `TINYINT(1)` in MySQL                                | Often used as boolean           |
| `biginteger`     | `BIGINT`                                             | Large whole numbers             |
| `float`          | `FLOAT` or `DOUBLE`                                  | Approximate values              |
| `decimal`        | `DECIMAL`, stored as `string` in PHP                 | Use for exact math (e.g. money) |
| `boolean`        | `BOOLEAN`, or `TINYINT(1)` in MySQL                  | True/false                      |
| `binary`         | `BLOB`, `BYTEA`                                      | Raw binary data                 |
| `date`           | `DATE`                                               | Returns `Cake\I18n\Date`        |
| `datetime`       | `DATETIME`, returns `Cake\I18n\FrozenTime`           | For full date & time            |
| `timestamp`      | `TIMESTAMP`                                          | With automatic update           |
| `time`           | `TIME`                                               | Time only                       |
| `json`           | `JSON`, or `TEXT` if not supported                   | Stores JSON data                |
| `enum`           | Enumerated string values                             | Must define allowed values      |
| `geometry`, etc. | Geospatial types                                     | For location data               |

DateTimeType is a core class that provides a way to handle DATETIME columns in your database using PHP's DateTimeImmutable and CakePHP's enhanced date/time features.

EnumType class allows you to map database columns to PHP Enums, making your code more type-safe, readable, and maintainable.

Geospatial Types refer to special database column types that store geographical or geometric data, such as coordinates and shapes.

custom types let you create your own logic for how data is stored in the database and how it's represented in PHP.

Connecting Custom Datatypes to Schema Reflection and Generation"
custom datatypes allow you to create your own logic for how specific database fields are:
   -> Converted from database to PHP (e.g. "456A>G" ‚Üí array),
   -> Converted from PHP to database,
   -> Handled during schema generation (for migrations),
   -> Handled during schema reflection (for reading DB schemas).

Mapping Custom Datatypes to SQL Expressions means telling CakePHP how to interpret complex SQL column types (like MySQL POINT, JSON, GEOMETRY, etc.) in PHP and vice versa‚Äîespecially when these values require custom logic to serialize/deserialize or to express in SQL queries.

Connection Classes represent database connections and provide the interface for executing queries, transactions, and schema management.

executing queries means interacting with the database using either the ORM (Object-Relational Mapping), Query Builder, or raw SQL execution.

transactions are used to ensure that a group of database operations are completed successfully as a unit.
============================================================
Query Builder 
https://chatgpt.com/c/6838032e-a6c0-8002-99dd-60b09a8fc836

Query Builder is a powerful, flexible, and secure way to build and execute SQL queries using a fluent, object-oriented API ‚Äî without writing raw SQL.
| Function          | Description                       | Example                                  |
| ----------------- | --------------------------------- | ---------------------------------------- |
| `count()`         | Counts rows or fields             | `$q->func()->count('*')`                 |
| `sum()`           | Sums values in a column           | `$q->func()->sum('price')`               |
| `avg()`           | Averages values in a column       | `$q->func()->avg('rating')`              |
| `min()` / `max()` | Get min/max value in a column     | `$q->func()->min('created')`             |
| `concat()`        | Concatenates strings              | `$q->func()->concat([...])`              |
| `dateDiff()`      | Gets difference between two dates | `$q->func()->dateDiff([...])`            |
| `now()`           | Gets current date/time            | `$q->func()->now()`                      |
| `cast()`          | Casts column to a type            | `$q->func()->cast('price', 'DECIMAL')`   |
| `coalesce()`      | Returns first non-null expression | `$q->func()->coalesce(['col1', 'col2'])` |

queries are lazily evaluated. This is a performance optimization: CakePHP does not run the SQL immediately when you call find() or add conditions like ->where(), ->orderBy(), etc.
| **Feature**                            | **Purpose / Use**                                                 |
| -------------------------------------- | ----------------------------------------------------------------- |
| Query Builder                          | Builds SQL queries with a fluent, chainable API.                  |
| The SelectQuery Object                 | Represents a SELECT query with customizable methods.              |
| Selecting Rows From A Table            | Retrieves multiple rows using `find()` and conditions.            |
| Selecting A Single Row From A Table    | Gets one row using `first()` or unique constraints.               |
| Getting A List Of Values From A Column | Extracts values from a single column as a list.                   |
| ResultSet Is A Collection Object       | Supports collection methods like `map()` and `filter()`.          |
| Queries Are Lazily Evaluated           | Improves performance: queries run only when results are accessed. |
| Selecting Data                         | Specifies what data columns to fetch.                             |
| Selecting Specific Fields              | Limits columns to improve performance.                            |
| Using SQL Functions                    | Applies SQL functions like `COUNT()`, `NOW()` in expressions.     |
| Window-Only Functions                  | Uses window functions like `RANK()` and `ROW_NUMBER()`.           |
| Custom Functions                       | Allows defining custom SQL expressions.                           |
| Ordering Results                       | Sorts query results using `orderBy()`.                            |
| Limiting Results                       | Limits the number of returned rows.                               |
| Aggregates - Group and Having          | Groups rows and filters using `group()` and `having()`.           |
| Case Statements                        | Adds conditional logic with `case()` expressions.                 |
| Fetching Arrays Instead of Entities    | Returns plain arrays using `enableHydration(false)`.              |
| Adding Calculated Fields               | Adds computed/derived fields via expressions.                     |
| Advanced Conditions                    | Supports complex conditional logic.                               |
| Using Identifiers in Expressions       | Safely quotes field names using `identifier()`.                   |
| Collation                              | Sets collation for string comparisons.                            |
| Automatically Creating IN Clauses      | Converts arrays in `where()` into `IN (...)` SQL.                 |
| Automatic IS NULL Creation             | Converts `null` in `where()` to `IS NULL`.                        |
| Automatic IS NOT NULL Creation         | Converts `'IS NOT' => null` to `IS NOT NULL`.                     |
| Raw Expressions                        | Injects raw SQL fragments safely.                                 |
| Using Connection Roles                 | Uses DB roles (e.g., read/write) for execution.                   |
| Expression Conjunction                 | Combines expressions with logical `AND`/`OR`.                     |
| Tuple Comparison                       | Compares multiple fields as a group.                              |
| Getting Results                        | Executes queries and fetches results.                             |
| Returning the Total Count of Records   | Uses `count()` to get number of matching rows.                    |
| Caching Loaded Results                 | Caches results with `cache()` for reuse.                          |
| Loading Associations                   | Eager loads related data via `contain()`.                         |
| Passing Conditions to Contain          | Filters associated data using conditions in `contain()`.          |
| Sorting Contained Associations         | Sorts associated records using `sort()` in `contain()`.           |
| Filtering by Associated Data           | Filters results based on related table data using `matching()`.   |
| Using innerJoinWith                    | Performs `INNER JOIN` with associated models.                     |
| Using notMatching                      | Filters out records with specific associations.                   |
| Using leftJoinWith                     | Performs `LEFT JOIN` to include unmatched associations.           |
| Adding Joins                           | Manually adds joins using `join()`.                               |
| Inserting Data                         | Inserts new records using `newEntity()` and `save()`.             |
| Updating Data                          | Updates existing records using `patchEntity()` and `save()`.      |
| Deleting Data                          | Deletes rows via `delete()` or query builder.                     |
| SQL Injection Prevention               | Secures queries using prepared statements and binding.            |
| Binding values                         | Binds values safely using `bind()` or placeholders.               |
| More Complex Queries                   | Builds advanced queries with joins, conditions, and expressions.  |
| Unions                                 | Combines multiple queries using `union()`.                        |
| Intersections                          | Returns common results across queries using `intersect()`.        |
| Subqueries                             | Embeds queries within others for filtering or data extraction.    |
| Adding Locking Statements              | Locks rows with statements like `FOR UPDATE`.                     |
| Window Functions                       | Uses analytical SQL functions for row-based stats.                |
| Common Table Expressions               | Adds modular `WITH` clauses for complex queries.                  |
| Executing Complex Queries              | Runs advanced raw or structured SQL using the builder.            |

================================================================================
https://chatgpt.com/c/68398c7c-0cc4-8002-bf1d-c7081a8725a8
Table Objects :-  In CakePHP, **Table Objects** represent database tables. 
                  They provide a way to interact with table data using 
                  CakePHP's **ORM (Object-Relational Mapping)**.
 
Purpose of Table Objects :-  To handle **CRUD operations**, define 
                             **associations**, apply **validation**, 
                             and manage **business logic** related to 
                             specific database tables.
Event List
| **Event Name**        | **Purpose**                                   |
| --------------------- | --------------------------------------------- |
| **initialize**        | Setup table (associations, behaviors, config) |
| **beforeMarshal**     | Modify data before converting to entities     |
| **afterMarshal**      | Inspect/modify entities after marshaling      |
| **beforeFind**        | Modify query before fetching data             |
| **buildValidator**    | Define validation rules                       |
| **buildRules**        | Define application rules (e.g., foreign keys) |
| **beforeRules**       | Before rules are checked                      |
| **afterRules**        | After rules are checked                       |
| **beforeSave**        | Before saving entity (can cancel save)        |
| **afterSave**         | After saving, before commit                   |
| **afterSaveCommit**   | After save transaction committed              |
| **beforeDelete**      | Before deleting entity (can cancel delete)    |
| **afterDelete**       | After deleting, before commit                 |
| **afterDeleteCommit** | After delete transaction committed            |

| **Topic**                        | **Purpose**                                                                |
| -------------------------------- | -------------------------------------------------------------------------- |
| **Table Objects**                | Represent and interact with database tables using CakePHP ORM.             |
| **Basic Usage**                  | Perform CRUD, define associations, and apply table-specific logic.         |
| **Customizing the Entity Class** | Use a custom class to represent a table row with additional logic.         |
| **Getting Table Instances**      | Retrieve table objects via `TableLocator` to reuse and manage consistency. |
| **Lifecycle Callbacks**          | Hook into the ORM process at different stages of entity/table operations.  |
| **Event List**                   | List of events triggered during ORM operations for customization.          |
| **initialize**                   | Set up table config, associations, behaviors, and default settings.        |
| **beforeMarshal**                | Modify or validate raw input data before it's converted into an entity.    |
| **afterMarshal**                 | Modify or inspect entity after data has been marshaled.                    |
| **beforeFind**                   | Modify or conditionally handle queries before execution.                   |
| **buildValidator**               | Define validation rules for incoming data.                                 |
| **buildRules**                   | Define application-level integrity rules (e.g., unique checks).            |
| **beforeRules**                  | Called before checking rules, allows short-circuiting.                     |
| **afterRules**                   | Called after rule checking to inspect results.                             |
| **beforeSave**                   | Modify or validate entity before saving to DB.                             |
| **afterSave**                    | Perform actions after entity has been saved.                               |
| **afterSaveCommit**              | Triggered after DB commit; useful for side effects like notifications.     |
| **beforeDelete**                 | Inspect or block delete before it happens.                                 |
| **afterDelete**                  | Actions to perform after deletion of an entity.                            |
| **afterDeleteCommit**            | Called after delete transaction is committed.                              |
| **Stopping Table Events**        | Halt event execution or skip further processing during callbacks.          |
| **Callback priorities**          | Control execution order when multiple listeners are attached.              |
| **Behaviors**                    | Reusable logic or traits that can be attached to tables (e.g., Timestamp). |
| **Configuring Connections**      | Use a specific DB connection for a table.                                  |
| **Using the TableLocator**       | Access and manage all table instances.                                     |
| **Configuring Table Objects**    | Set options like entity class, table name, and connection.                 |
| **Flushing the Registry**        | Clear stored table instances from memory (reset TableLocator).             |
| **Configuring Namespace**        | Set custom namespace to locate your ORM classes (tables/entities).         |

==========================================
Entity represents a single row of data in a table and provides an object-oriented way to interact with that row, including data access, modification, validation, custom getters/setters, and mass assignment protection.

Accessor is a special method you define inside an Entity class to control how a field‚Äôs value is returned when it is accessed.

Mutator is a method that runs when a value is set on an entity field. It allows you to:
Modify, sanitize, or transform the data before it's saved.
Optionally, set related fields based on the value.

Virtual Fields are custom, computed fields that don‚Äôt exist in your database, but behave like normal properties on your entity objects.

entities track changes to their fields‚Äîthis is often referred to as the "dirty state"

validation errors are attached directly to the entity object after you attempt to save or patch it. 

mass assignment protection system helps you secure your entities by controlling which fields can be populated in bulk 

when you create a new entity and pass data in bulk (mass assignment), by default mass assignment protection is enabled ‚Äî meaning fields not allowed in the entity‚Äôs $_accessible property will be ignored for security.

| **Feature**             | **Purpose (Short)**                    |
| ----------------------- | -------------------------------------- |
| Entities                | Represent a DB row as an object.       |
| Creating Entity Classes | Define logic/structure for a row.      |
| Creating Entities       | Instantiate a new record.              |
| Accessing Entity Data   | Get/set field values.                  |
| Accessors               | Format data when reading.              |
| Mutators                | Format data before saving.             |
| Virtual Fields          | Create computed fields.                |
| Modified Check          | Check if a field changed.              |
| Validation Errors       | Get validation issues.                 |
| Mass Assignment         | Securely assign multiple fields.       |
| Avoid Mass Protection   | Allow all fields (use cautiously).     |
| Modify Guarded Fields   | Change allowed fields dynamically.     |
| Bypass Guarding         | Set fields directly even if protected. |
| Persisted Check         | Check if entity is new or loaded.      |
| Lazy Loading            | Load associations when accessed.       |
| Traits                  | Reuse code across entities.            |
| Convert to Array/JSON   | Output for APIs/frontends.             |
| Expose Virtual Fields   | Show computed fields in output.        |
| Hide Fields             | Hide sensitive data (e.g., password).  |
| Complex Types           | Store arrays/JSON in DB.               |
================================================================
https://chatgpt.com/c/683c29a7-6bf8-8002-bb55-9dabb1f0439c
| Relationship | Association Type | Description                                                         | Example                          |
| ------------ | ---------------- | ------------------------------------------------------------------- | -------------------------------- |
| One-to-One   | `hasOne`         | A record in one table is linked to one in another                   | A user has one profile           |
| One-to-Many  | `hasMany`        | A record in one table is linked to many in another                  | A user has many articles         |
| Many-to-One  | `belongsTo`      | Many records in a table link to one in another                      | Many articles belong to one user |
| Many-to-Many | `belongsToMany`  | Records in one table are linked to many in another (and vice versa) | Articles belong to many tags     |

associations (or relationships) define how tables (models) in your application are related to one another.

hasOne association defines a one-to-one relationship where your current table (the source) has one associated record in another table (the target).

belongsTo association is used when a table (source) belongs to another table (target).

hasMany association is used to model one-to-many relationships, where one record in a table can be related to multiple records in another table.

belongsToMany association is used to represent a many-to-many relationship between two tables.

belongsToMany association with the through option is used when you want more control over the join table in a many-to-many relationship‚Äîespecially when: need to store extra fields (like grade, days_attended).

ORM allows you to customize how associated data is fetched using custom finders.

when defining associations between tables, CakePHP uses conventions to automatically determine 

once you have defined associations (like belongsTo, hasMany, belongsToMany, etc.) in your table classes, you can load associated data when retrieving records using eager loading.
| **Feature**                    | **Purpose (Short)**                                                       |
| ------------------------------ | ------------------------------------------------------------------------- |
| **HasOne Associations**        | Link one record in this table to **one** in another (1:1).                |
| **BelongsTo Associations**     | Link this table‚Äôs record to a parent in another (inverse of HasOne).      |
| **HasMany Associations**       | Link one record in this table to **many** in another (1\:N).              |
| **BelongsToMany Associations** | Link many records in this table to many in another (N\:N via join table). |
| `through` Option               | Use a **custom join table** entity for BelongsToMany.                     |
| Association Finders            | Use **custom finder methods** when fetching associated data.              |
| Association Conventions        | Defines naming and foreign key **naming rules** for associations.         |
| Loading Associations           | Fetch related data using `contain()` or lazy-loading.                     |

=============================================
https://chatgpt.com/c/683d2524-7264-8002-bd74-48817d72caff
retrieving data and result sets involves using the ORM (Object-Relational Mapping) to interact with the database in a clean, object-oriented way. This concept is mainly handled through Table classes, Query Builder, and Entity objects.

debugging queries and result sets requires special care because the ORM returns complex objects like Query, ResultSet, and Entity.
| Expression                         | Description                                | Shows Results? |
| ---------------------------------- | ------------------------------------------ | -------------- |
| `debug($query)`                    | Shows internal Query state and bindings    | ‚ùå              |
| `sql($query)`                      | Shows final SQL string (requires DebugKit) | ‚ùå              |
| `debug($query->all())`             | Shows ResultSet object (not contents)      | ‚ùå              |
| `debug($query->toList())`          | Shows result records as array of entities  | ‚úÖ              |
| `debug(iterator_to_array($query))` | Forces result as array                     | ‚úÖ              |
| `debug(json_encode($query))`       | Pretty JSON-encoded result set             | ‚úÖ              |
| `debug($query->first())`           | Shows a single entity object               | ‚úÖ              |
| `debug((string)$query->first())`   | Entity as JSON string                      | ‚úÖ              |

getting a single entity by primary key means retrieving one specific row from a database table using its primary key (usually the id column). 

finders are methods used to retrieve data from the database using the Query Builder.They allow you to write clean, reusable, and powerful queries when working with the ORM (Object-Relational Mapping).
| Finder Method       | Description                                |
| ------------------- | ------------------------------------------ |
| `find('all')`       | Gets all records (default)                 |
| `find('list')`      | Gets key-value pairs (e.g., for dropdowns) |
| `find('threaded')`  | Gets hierarchical data (e.g., comments)    |
| `find('neighbors')` | Gets previous and next records by ID       |
| `find('path')`      | Finds a path to a node in tree structures  |
| `find('bySlug')`    | Example of a **custom finder**             |

first() is a method used to fetch only the first row of a query result. It's commonly used when you expect just one result from a query (not multiple).

count() method is used to retrieve the number of records that match a query. It is useful when you want to know how many rows exist without actually loading all the data.

Finding Key/Value Pairs using the find('list') method allows you to retrieve an associative array from your database table, where:
The keys are identifiers (e.g., IDs, slugs),
The values are labels (e.g., titles, names),
The result is ideal for use in <select> dropdowns, JSON responses, etc.

Customize Key-Value Output in find('list') lets you generate dynamic labels and keys for dropdowns or associative arrays using virtual fields, accessors, or callback functions. 

find('threaded') is a powerful built-in finder that retrieves hierarchical (nested) data from a table where records are stored in an adjacency list format‚Äîtypically using a parent_id column.

Custom Finder Methods in CakePHP 5 are a way to encapsulate reusable and complex query logic directly in your table classess

Dynamic Finders are a convenient shortcut in CakePHP's ORM that let you query your database using method names built from your table's fields, without writing explicit where() conditions.

retrieving associated (related) data ‚Äî like fetching an article and its author, or users and their comments ‚Äî is a key ORM feature. 

when you query models using find(), associated (related) data is not loaded by default. To load associated models (like authors of articles or comments on posts), you use contain() ‚Äî this is called eager loading.

the contain() method is used to eager-load associated data, and you can also filter that associated data using conditions, custom finders, or query options.

when you eager load associated data using contain()‚Äîespecially for HasMany or BelongsToMany relationships‚Äîyou may want to sort the associated records.

you want to filter your primary model based on associated data, you use the matching() method instead of contain().

innerJoinWith() is a method used to create an INNER JOIN between your main table and an associated table without fetching the associated data.

notMatching() is the inverse of matching(). It‚Äôs used to filter records that do not have related data in a specific association.

leftJoinWith() is used to create a LEFT JOIN SQL clause with one or more associations without fetching associated data into the result.

fetching strategy refers to how associated data is retrieved when using contain() in your queries.

subquery strategy is a method for loading associated data (especially hasMany or belongsToMany) using SQL subqueries instead of standard JOINs or multiple queries.

lazy loading means fetching associated records only when needed, after the main entity has been loaded ‚Äî instead of loading them all upfront (as done with eager loading via contain()).

when you execute a query using all(), it returns a ResultSet object ‚Äî specifically, an instance of Cake\ORM\ResultSet.
This object represents the rows returned by the query and provides powerful manipulation capabilities by behaving like a Collection.

You can easily retrieve the first or last record from that result set using:
first() ‚Äì returns the first row
last() ‚Äì returns the last row

ResultSet is a collection of entity objects returned from a query. If you want to access a record at a specific position (index) ‚Äî not just the first or last ‚Äî you can combine the skip() and first() methods.
syntax = $row = $resultSet->skip(N)->first();

You can check whether this result set contains any data using the isEmpty() method.

after you fetch some data (like a list of articles or a user), you might later decide to load related data (like comments or posts) without running the main query again.You can do this using the loadInto() method.

when you fetch data using find(), sometimes you want to group, restructure, or analyze that data in a custom way after it's loaded from the database.

Map/Reduce is a feature that allows you to process, transform, or group query results after they are fetched from the database.

Stacking multiple operations means you can keep chaining more query modifiers even after adding a mapReduce() step. You can keep adding:
Filters (->where())
Other finders (->find())
More mapReduce operations (->mapReduce())

Removing All Stacked Map-reduce Operations in CakePHP 5 means clearing out all previously added mapReduce processing functions (mapper and reducer) from a query so that no mapReduce transformations will be applied when the query is executed.

| **Feature**                                  | **Purpose (Short)**                                              |
| -------------------------------------------- | ---------------------------------------------------------------- |
| **Debugging Queries and ResultSets**         | Inspect SQL queries and results for troubleshooting.             |
| **Getting a Single Entity by Primary Key**   | Fetch a row by its primary key (`get()` method).                 |
| **Using Finders to Load Data**               | Use `find()` for flexible query building.                        |
| **Getting the First Result**                 | Use `first()` to get the first matching record.                  |
| **Getting a Count of Results**               | Use `count()` to count matched rows.                             |
| **Finding Key/Value Pairs**                  | Use `find('list')` to get key-value pairs.                       |
| **Customize Key-Value Output**               | Define which columns are used as keys/values in lists.           |
| **Finding Threaded Data**                    | Fetch hierarchical (nested) data (e.g., categories, comments).   |
| **Custom Finder Methods**                    | Add reusable named query logic in your table class.              |
| **Dynamic Finders**                          | Auto-generated finders like `findByEmail()`.                     |
| **Retrieving Associated Data**               | Fetch related records (e.g., user‚Äôs posts).                      |
| **Eager Loading via Contain**                | Load associations in the same query to reduce DB hits.           |
| **Passing Conditions to Contain**            | Filter associated data inside `contain()`.                       |
| **Sorting Contained Associations**           | Order associated data within `contain()`.                        |
| **Filtering via Matching and Joins**         | Filter main records based on associated data.                    |
| **Using innerJoinWith**                      | Use `INNER JOIN` for filtering by association.                   |
| **Using notMatching**                        | Get records that do **not** have matching associated data.       |
| **Using leftJoinWith**                       | Use `LEFT JOIN` to include all records with optional matches.    |
| **Changing Fetching Strategies**             | Change how associated data is fetched (select, subquery, etc.).  |
| **Fetching With Subquery Strategy**          | Use subqueries to fetch associations (optimized for large sets). |
| **Lazy Loading Associations**                | Load associated records only when accessed.                      |
| **Getting First & Last Record in ResultSet** | Use `first()` and `last()` on result sets.                       |
| **Getting Arbitrary Index in ResultSet**     | Access result set elements by index like an array.               |
| **Checking if ResultSet is Empty**           | Use `isEmpty()` to check if results exist.                       |
| **Loading Additional Associations**          | Add more associations to an already loaded entity.               |
| **Modifying Results with Map/Reduce**        | Transform result sets using map/reduce functions.                |
| **Stacking Multiple Operations**             | Combine several transformations or filters.                      |
| **Removing All Stacked Map/Reduce Ops**      | Reset/clear applied map-reduce logic.                            |

======================================================
https://chatgpt.com/c/683d6527-cf88-8002-8fd3-eb463b321079

Validating Data in CakePHP 5 refers to the structured process of checking that the data your application receives is correct, complete, and logically valid before saving it to the database.

before data from a request is turned into an entity (i.e., a model object), CakePHP validates it to ensure that it's the correct type, shape, and format.

Creating a default validation set in CakePHP 5 means defining a standard group of validation rules that will be automatically applied when building or updating entities (e.g., when using newEntity() or patchEntity()).

Using a Different Validation Set" means applying a custom set of validation rules‚Äîother than the default‚Äîto specific scenarios like updating a record, submitting a form, or handling an API request.

when you're saving entities with associated data (like related Users or Comments), you can apply different validation sets to each associated model‚Äînot just the main entity.

when saving an entity with associated (related) data, you can apply specific validation rule sets to each associated table/model.

Combining validators in CakePHP 5 means reusing and extending existing validation rules by calling one validation method inside another.

Validation Providers in CakePHP 5 are sources or classes where validation rule methods are defined.

after defining one or more validation sets in your table class (like validationDefault(), validationHardened(), etc.), you can retrieve these validator objects programmatically using the getValidator() method.

Applying Application Rules in CakePHP 5 refers to enforcing business logic and data integrity rules right before saving or deleting an entity in the database.

Rules Checker is used to define application-level rules (also called domain rules) that ensure your data meets business logic before it's saved to the database.

unique field rules are application-level constraints that ensure certain fields (like email, username, etc.) do not have duplicate values in the database.

Foreign Key Rules are application-level constraints defined in the buildRules() method of a Table class to ensure that a related record exists in the foreign (associated) table before saving data.

Association Count Rules are application rules that ensure an associated property (like hasMany or belongsToMany) contains a specific number of related items before saving an entity.

Association Link Constraint Rule is a domain-level rule that allows you to emulate SQL-level constraints at the application layer.

Using Entity Methods as Rules means you can define custom validation or domain logic inside your Entity class as methods, then call these methods as rules when validating or saving data in your Table class.

Using Conditional Rules means you can define application rules that apply only under certain conditions, based on the data or state of the entity being validated or saved.

Creating custom reusable rules in CakePHP 5 means defining your own application/domain validation logic as methods or callable objects that can be added to the rules checker and reused across different tables or entities.

Creating Custom Rule Objects in CakePHP 5 means packaging your domain validation logic into dedicated, reusable PHP classes instead of just closures or methods in the Table class.

Disabling Rules means temporarily turning off the application rules (domain rules) validation when saving an entity.

Validation Checks that the data format, types, and values are correct (e.g., email is valid, required fields are present).
Application Rules Enforce business logic and data consistency related to application state or existing data.

validation and application rules are typically two separate layers with different purposes:
   Validation ensures the data format and structure is correct (e.g., an email is valid).
   Application rules enforce domain or business logic (e.g., email uniqueness).

Validation runs when creating (newEntity()) or updating (patchEntity()) entities from raw data.
Application rules run automatically when saving entities (save()), to check things like uniqueness or foreign key constraints.

Removing Rules in CakePHP 5 refers to the ability to delete previously added application rules from a RulesChecker instance.

| **Feature**                               | **Purpose (Short)**                                              |
| ----------------------------------------- | ---------------------------------------------------------------- |
| **Validating Data**                       | Ensure input data meets expected format before saving.           |
| **Validating Before Building Entities**   | Validate raw data before creating entity objects.                |
| **Creating a Default Validation Set**     | Define default validation rules for a table.                     |
| **Using a Different Validation Set**      | Apply alternate validation logic (e.g., for login).              |
| **Validation for Associations**           | Use specific validation sets for associated models.              |
| **Combining Validators**                  | Merge multiple validators into one.                              |
| **Validation Providers**                  | Use custom classes/methods for validation logic.                 |
| **Getting Validators From Tables**        | Retrieve validator objects via table methods.                    |
| **Default Validator Class**               | Override default validator behavior by customizing class.        |
| **Applying Application Rules**            | Enforce business rules beyond field validation.                  |
| **Creating a Rules Checker**              | Define rules applied after validation, before saving.            |
| **Creating Unique Field Rules**           | Ensure a field value is unique in the DB.                        |
| **Foreign Key Rules**                     | Check if foreign key references exist.                           |
| **Association Count Rules**               | Validate counts of associated records (e.g., at least one).      |
| **Association Link Constraint Rule**      | Ensure associated records exist before saving link.              |
| **Using Entity Methods as Rules**         | Use custom entity methods to define save conditions.             |
| **Using Conditional Rules**               | Apply rules based on other field values.                         |
| **Dynamic Error Messages**                | Customize error messages based on condition.                     |
| **Creating Custom Reusable Rules**        | Define global rule logic usable across models.                   |
| **Creating Custom Rule Objects**          | Build reusable rule objects using `Rule` class.                  |
| **Disabling Rules**                       | Temporarily skip application rules for an entity.                |
| **Validation vs. Application Rules**      | Validation = data structure; Application rules = business logic. |
| **Using Validation as Application Rules** | Reuse validation logic at application rule level.                |
| **Removing Rules**                        | Remove specific rules from the rules checker.                    |

===================================================================
https://chatgpt.com/c/683d9fb0-ae70-8002-8b50-ed30392f068e

saving data typically means storing or updating data in the database using ORM entities and table objects. CakePHP‚Äôs ORM makes it easy to interact with your database in an object-oriented way.

A Glance Over Saving Data‚Äù refers to an overview of how the framework handles saving data into the database using its ORM (Object-Relational Mapping) system.
üîπ 1. Saving Data via Web Forms
üîπ 2. Saving Data Programmatically (Without Forms)

Inserting data in CakePHP 5 means creating and saving new records (rows) into a database table using the ORM (Object-Relational Mapping) system.

Updating data in CakePHP 5 refers to modifying an existing record in the database using the ORM's entity and table classes. 

Saving with associations in CakePHP 5 refers to the ability of the save() method to persist not just a single entity (like an article), but also its related data (like comments, tags, or authors) ‚Äî all at once.

associating many-to-many records means linking records from two related tables using a join table. You typically do this with belongsToMany() associations.

unlinking many-to-many records means removing associations between two related entities that are connected via a join table, without deleting the actual records from the related tables.

converting request data into entities means transforming the raw request array data (usually from a form) into structured Entity objects that the ORM (Object-Relational Mapping) can work with ‚Äî including validation, association handling, and field access control.

Converting BelongsToMany data in CakePHP means turning form or request data into a format that correctly represents many-to-many relationships using the newEntity() or patchEntity() methods.

Converting hasMany data in CakePHP means transforming form/request data into related child entities for a parent entity.

Converting multiple records means turning an array of data‚Äîeach representing one record‚Äîinto multiple entity objects at once. This is useful when you want to create or update many records in a single form submission.

Merging request data into entities means updating an existing entity with new data from a request (usually a form).

patchEntity() is a method used to update an existing entity with new data from a request. Before updating, it validates the data to ensure it meets the rules you set.

Patching associations means updating related data (like related comments, tags, or users) inside an entity when you patch it with new request data.

beforeMarshal is an event in CakePHP that lets you change or clean up the data just before CakePHP turns it into entities (objects representing your database records).

The afterMarshal event in CakePHP lets you modify or check an entity after it has been created or updated from the request data but before it is saved.

Validating Data Before Building Entities means checking if the input data is correct and follows certain rules before turning it into an entity that can be saved in the database.

Mass Assignment Attack means when a user sends extra fields in form data that change something they should not be allowed to change (like user_id, role, or is_admin), and your code accidentally accepts those values.

The save() method in CakePHP is used to insert new data or update existing records in your database using entities.

Saving associations means saving related data (like comments, tags, authors) together with the main entity (like an article).

When your entity (like Article) belongs to another entity (like User), you can save both at the same time ‚Äî this is called saving a belongsTo association.

A hasOne association is used when one record in a table is related to exactly one record in another table. 

A hasMany association means one record relates to multiple records in another table (e.g., an article has many comments). 

A belongsToMany association models a many-to-many relationship using a junction table (e.g., articles_tags).

In CakePHP, when two tables have a belongsToMany relationship, the join table (also called a junction table) connects them.

Complex types like arrays and objects cannot be stored directly in the database.
To store them, CakePHP uses custom types like JSON to convert (serialize) the data when saving and convert it back (unserialize) when reading.

saveOrFail() is a method in CakePHP's ORM (Cake\ORM\Table) that attempts to save an entity to the database.

findOrCreate() is a method in CakePHP‚Äôs ORM (Cake\ORM\Table) that tries to find an existing record matching some search criteria. 

Creating a new database record using an existing primary key value (like a UUID) means you manually set the primary key instead of letting CakePHP generate it automatically.

saveMany() is used to save multiple records (entities) at once in CakePHP, often in a single transaction.

updateAll() is a CakePHP method used to update multiple rows at once in the database without loading entities into memory.
| **Feature**                                 | **Purpose (Short)**                                                |
| ------------------------------------------- | ------------------------------------------------------------------ |
| **A Glance Over Saving Data**               | Overview of how CakePHP handles saving data.                       |
| **Inserting Data**                          | Save a new entity to the database.                                 |
| **Updating Data**                           | Save changes to an existing entity.                                |
| **Saving With Associations**                | Save related records together.                                     |
| **Associate Many To Many Records**          | Link records in many-to-many associations.                         |
| **Unlink Many To Many Records**             | Remove links in many-to-many associations.                         |
| **Converting Request Data into Entities**   | Turn form/request input into entity objects.                       |
| **Converting BelongsToMany Data**           | Handle incoming many-to-many request data.                         |
| **Converting HasMany Data**                 | Handle incoming one-to-many request data.                          |
| **Converting Multiple Records**             | Handle batch entity creation or updates.                           |
| **Changing Accessible Fields**              | Control which fields can be mass-assigned.                         |
| **Merging Request Data Into Entities**      | Use `patchEntity()` to update entities with request data.          |
| **Validation and patchEntity**              | Validate data while patching entities.                             |
| **Patching HasMany and BelongsToMany**      | Update associated records when patching.                           |
| **Modifying Data Before Building Entities** | Change request data before converting to entities.                 |
| **Modifying After Updating From Request**   | Tweak the entity after patching but before saving.                 |
| **Validating Before Building Entities**     | Run validation on raw data before entity creation.                 |
| **Avoiding Mass Assignment Attacks**        | Protect sensitive fields from unintended updates.                  |
| **Saving Entities**                         | Save a single entity to the database.                              |
| **Saving Associations**                     | Save entity and its associations in one go.                        |
| **Saving BelongsTo Associations**           | Save parent-related entity.                                        |
| **Saving HasOne Associations**              | Save directly related single entity.                               |
| **Saving HasMany Associations**             | Save multiple related records.                                     |
| **Saving BelongsToMany Associations**       | Save many-to-many related records and links.                       |
| **Saving Data to Join Table**               | Add extra fields while saving many-to-many associations.           |
| **Saving Complex Types**                    | Save JSON, array, or custom objects in fields.                     |
| **Strict Saving**                           | Enforce validation/rule failures with exceptions (`saveOrFail()`). |
| **Find or Create an Entity**                | Search for a record or create it if not found.                     |
| **Creating with Existing Primary Key**      | Add a new record using a known primary key.                        |
| **Saving Multiple Entities**                | Save multiple entities in one operation.                           |
| **Bulk Updates**                            | Update many rows directly without loading entities.                |

======================================================
https://chatgpt.com/c/683e9191-2938-8002-876d-777a9c5baf70
Deleting Data in CakePHP 5 refers to the process of removing records (entities) from the database using the ORM (Table class).

Cascading Deletes are a way to automatically delete associated records (in related tables) when a parent entity is deleted.

Bulk delete refers to the process of deleting multiple records from the database at once.

Strict Deletes This method attempts to delete a single entity and throws an exception if the deletion fails for any reason.

| **Feature**           | **Purpose (Short)**                                                                        |
| --------------------- | ------------------------------------------------------------------------------------------ |
| **Deleting Data**     | Remove a single entity or record from the database.                                        |
| **Cascading Deletes** | Automatically delete associated records (e.g., `HasMany`) when the main record is deleted. |
| **Bulk Deletes**      | Delete multiple records at once using conditions (without loading entities).               |
| **Strict Deletes**    | Use `deleteOrFail()` to throw exceptions if delete fails.                                  |

======================================================
Behaviors 

Behaviors are reusable chunks of logic that can be attached to one or more Table classes to extend their functionality without repeating code.
üîÑ What are Behaviors?
Behaviors are modular, reusable logic that can be attached to any Table class (like BlogsTable, ArticlesTable, etc.) in CakePHP.

üîß Why Not Traits?
Traits are limited ‚Äî they don‚Äôt support event handling (beforeSave, afterSave, etc.), which is crucial for behaviors like TimestampBehavior.

üß† What Does TimestampBehavior Do?
It automatically sets date/time fields like created_at and modified_at when saving a record ‚Äî you don‚Äôt need to handle this manually.

mixin methods are public methods defined in a behavior class that become available on the table class where the behavior is attached.

Limiting or Renaming Exposed Mixin Methods in CakePHP 5 refers to controlling which behavior methods are accessible (or ‚Äúmixed in‚Äù) directly on your Table objects, and optionally renaming them to avoid conflicts or provide clearer method names.

Defining Event Listeners in CakePHP 5 means creating methods inside a behavior that automatically respond to specific lifecycle events of a Table or Entity, such as before saving data, after deleting, or before validation.

Defining Finders in CakePHP 5 refers to creating custom query methods inside behaviors (or tables) that simplify retrieving data based on specific criteria.

Event Listeners in behaviors let you hook into ORM lifecycle events, like beforeSave, afterSave, etc.

public methods in a behavior become available on the table using "mixin" methods. If you want to hide them or rename them, you can use the implementedMethods config.

Custom finders are methods that allow you to define reusable query logic. They live in your Table classes or Behaviors, and are named like findSlug(), findActive(), etc.

finder methods allow you to customize how you fetch data (e.g., find('slug') to find by slug). 

when request data is converted (marshalled) into entities, behaviors can customize how specific fields are transformed by implementing the PropertyMarshalInterface. 

behaviors are attached to tables to add reusable functionality. Sometimes, you may want to remove a behavior that was previously attached to a table.

When you attach behaviors to a table in CakePHP, you might want to check which behaviors are currently loaded, verify if a particular behavior is loaded, or get access to a specific behavior instance to call its methods.

Re-configuring loaded behaviors means changing the settings (configuration) of a behavior after it has already been attached (loaded) to a table. 
| **Feature**               | **Purpose (Very Short)**             |
| ------------------------- | ------------------------------------ |
| Using Behaviors           | Add reusable model logic             |
| Core Behaviors            | Built-in behaviors (e.g., Timestamp) |
| Creating a Behavior       | Make custom behaviors                |
| Defining Mixin Methods    | Add methods to table via behavior    |
| Limiting/Renaming Methods | Control exposed behavior methods     |
| Defining Event Listeners  | React to model events                |
| Defining Finders          | Add custom finders                   |
| Limiting/Renaming Finders | Control finder method exposure       |
| Transforming Request Data | Modify data before entity creation   |
| Removing Behaviors        | Detach behaviors at runtime          |
| Accessing Behaviors       | Get loaded behavior instances        |
| Re-configuring Behaviors  | Change behavior settings             |
------------------------------------------
CounterCache is a feature in CakePHP that automatically keeps a count of related records in a specific column of a related table. 

Basic Usage" refers to the standard or minimal setup required to use a feature or behavior effectively.

Advanced Usage refers to using more sophisticated configurations or custom logic with a CakePHP feature. 

CounterCache works on belongsTo associations by updating a count field on the "parent" table when related records are added or removed.

updateCounterCache() is a method provided by the CounterCacheBehavior.
It recalculates and updates the cached counter values for all or specific associated records.

| **Topic**                      | **Purpose (Short)**                                                      |
| ------------------------------ | ------------------------------------------------------------------------ |
| **CounterCache**               | Automatically keep count of related records in a field.                  |
| **Basic Usage**                | Auto-update a counter field (e.g., number of comments per post).         |
| **Advanced Usage**             | Customize which records update the counter and how.                      |
| **BelongsToMany Usage**        | Use counter cache with many-to-many associations.                        |
| **Manually Updating Counters** | Explicitly update counters in code when automatic updates aren‚Äôt enough. |
------------------------------------
The TimestampBehavior is a CakePHP ORM behavior that automatically updates timestamp fields on entities whenever certain events occur, typically:
created ‚Äî when a new record is inserted.
modified (or updated) ‚Äî when an existing record is updated.

Using and Configuring the Behavior in CakePHP 5 means customizing how a behavior (like TimestampBehavior) works by changing its default settings to fit your application needs.

Touching a record means updating only the timestamp fields (like modified, or any other timestamp configured) of an entity without changing any other data.

TimestampBehavior automatically updates timestamp fields like created and modified.

| **Topic**               | **Purpose**                      |
| ----------------------- | -------------------------------- |
| Basic Usage             | Auto-set created/modified times  |
| Configuring Behavior    | Customize fields and timing      |
| Updating Timestamps     | Refresh timestamps on change     |
| Saving Without Updating | Save without changing timestamps |

-------------------------------------
https://chatgpt.com/c/683fe507-6be0-8002-a66e-910b0dea67be
TranslateBehavior allows you to store and retrieve translated versions of specific fields (like title, content, etc.) for different languages.

Translation Strategies refer to how CakePHP stores and manages multilingual content using the Translate behavior.

Shadow Table Strategy is one of the two supported strategies for managing multilingual content using the TranslateBehavior

EAV Strategy (Entity-Attribute-Value) is an alternative to the Shadow Table Strategy for storing translations with the TranslateBehavior.

attaching the TranslateBehavior to your tables enables automatic multilingual support for specified fields in your database tables

EAV Strategy for translations, by default it stores all translations in a shared i18n table

"Reading Translated Content" means loading and displaying data in the user‚Äôs preferred language using the TranslateBehavior.

when you're using the TranslateBehavior for multilingual content, sometimes you want to retrieve and display all translations of a single record (e.g., for an admin panel where users can edit content in multiple languages at once).

"Limiting the Translations to be Retrieved" refers to restricting which locales (languages) are loaded when you use the TranslateBehavior to fetch translations for a model.

Preventing Retrieval of Empty Translations" is a feature of the TranslateBehavior that controls whether translations with empty strings should overwrite the original field values or not.

"Retrieving All Translations For Associations" means fetching translated content not only for the primary model (e.g., Articles), but also for its related associated models (e.g., Categories) in one single query operation.

"Retrieving one language without using I18n::setLocale" means fetching translated content for a specific locale (language) on a per-table basis without changing the global or application-wide locale setting.

"Querying Translated Fields" refers to the technique of searching or filtering records based on translated content stored via the TranslateBehavior.

"Saving in Another Language" with TranslateBehavior means saving translated versions of fields (like title, body) for a record in a different locale (language) than the default, enabling multilingual content management.

Saving Multiple Translations allows you to add or update translations for multiple languages on a single entity at once, using the TranslateTrait in your entity class and special form inputs.

Validating Translated Entities means applying validation rules specifically to translation records managed by the TranslateBehavior when you create or update translated data through entities.

| **Topic**                                           | **Purpose (Short)**                                                        |
| --------------------------------------------------- | -------------------------------------------------------------------------- |
| **Translation Strategies**                          | Different methods to handle multilingual content.                          |
| **Shadow Table Strategy**                           | Store translations in a separate table mirroring main table.               |
| **EAV Strategy**                                    | Use Entity-Attribute-Value model for translations.                         |
| **Attaching Translate Behavior**                    | Enable translation features on your tables.                                |
| **Quick Tour**                                      | Overview of basic translation usage.                                       |
| **Using Separate Translations Table (EAV)**         | Store translations in dedicated translations table.                        |
| **Reading Translated Content**                      | Fetch translated fields transparently.                                     |
| **Retrieve All Translations for Entity**            | Get all language versions of a record.                                     |
| **Limiting Translations Retrieved**                 | Restrict which translations are loaded.                                    |
| **Preventing Retrieval of Empty Translations**      | Skip translations with no content.                                         |
| **Retrieving Translations for Associations**        | Get translations for related associated records.                           |
| **Retrieving One Language Without I18n::setLocale** | Fetch translations for a specific language without changing global locale. |
| **Querying Translated Fields**                      | Search/filter data based on translated fields.                             |
| **Saving in Another Language**                      | Save translation in a language different from current locale.              |
| **Saving Multiple Translations**                    | Save multiple language versions at once.                                   |
| **Validating Translated Entities**                  | Apply validation rules on translated fields/entities.                      |
-------------------------------
TreeBehavior is a behavior designed to help you manage and work with hierarchical data stored in a single database table.

TreeBehavior requires your database table to have specific columns to properly store and manage the hierarchical tree structure using the Modified Preorder Tree Traversal (MPTT) technique.
| Column Name | Type             | Purpose                                                  | Notes                                                                          |
| ----------- | ---------------- | -------------------------------------------------------- | ------------------------------------------------------------------------------ |
| `parent_id` | Nullable integer | Stores the ID of the **parent node** for each row        | Should be indexed for performance. Allows building parent-child relationships. |
| `lft`       | Integer (signed) | Stores the **left boundary** value for nested set logic  | Used internally by TreeBehavior to maintain tree order. Should be indexed.     |
| `rght`      | Integer (signed) | Stores the **right boundary** value for nested set logic | Also used internally to represent subtree boundaries.                          |

TreeBehavior, getting direct descendants refers to retrieving the immediate child nodes of a given parent node within a hierarchical tree structure.

Finding a path or branch in the tree refers to retrieving the ancestral path (breadcrumb trail) from a specific node up to the root in a hierarchical structure managed by the TreeBehavior.

Configuration for the TreeBehavior refers to customizing the column names that the behavior uses to manage hierarchical data structures like category trees, threaded comments, or nested menus.

Node Level (Depth) in TreeBehavior refers to the hierarchical depth (or level) of a node in a tree structure ‚Äî that is, how far a node is from the root of the tree.

Scoping and Multi Trees refers to the ability of TreeBehavior to manage multiple independent tree structures within a single database table by applying a scope.

Deletion Behavior in TreeBehavior refers to how tree nodes (and their children) are deleted from the database, and whether ORM callbacks (like beforeDelete and afterDelete) are triggered for each node.

‚ÄúRecovering with custom sort field‚Äù refers to how the TreeBehavior's recover() method rebuilds the lft and rght fields of a tree structure when they are corrupted or out of sync ‚Äî using a custom sort order instead of the default.

Saving Hierarchical Data refers to how you manage and persist parent-child relationships in a database table using the TreeBehavior

Deleting Nodes refers to how you remove entities from a hierarchical tree when using the TreeBehavior

| **Topic**                        | **Purpose (Short)**                                                 |
| -------------------------------- | ------------------------------------------------------------------- |
| **Requirements**                 | Prerequisites for using Tree behavior (e.g., `lft`, `rght` fields). |
| **A Quick Tour**                 | Overview of Tree behavior features and usage.                       |
| **Getting Direct Descendents**   | Retrieve immediate child nodes of a tree node.                      |
| **Getting Formatted Tree Lists** | Get hierarchical lists formatted for dropdowns or menus.            |
| **Finding a Path or Branch**     | Find ancestors or a subtree from a given node.                      |
| **Configuration**                | Customize Tree behavior settings (fields, order, etc.).             |
| **Node Level (Depth)**           | Determine the depth level of nodes in the tree.                     |
| **Scoping and Multi Trees**      | Handle multiple independent trees within one table.                 |
| **Deletion Behavior**            | Control what happens to child nodes when deleting a node.           |
| **Recovering with Custom Sort**  | Repair tree structure using a custom field for sorting.             |
| **Saving Hierarchical Data**     | Add or update nodes maintaining tree structure.                     |
| **Deleting Nodes**               | Remove nodes and adjust tree accordingly.                           |
