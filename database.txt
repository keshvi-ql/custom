git clone https://github.com/keshvi-ql/custom.git
git status
git add .
git commit -m "COMMIT_MESSAGE"
git push -u origin main

username = keshvi-ql
git = keshvi.g@queueloopsolutions.com
pass = Keshvi@106
----------------------------
https://chatgpt.com/c/6836b33d-1c18-8002-812f-dccedd1e6bfc

Database Access and ORM (Object-Relational Mapping) provide a structured and secure way to interact with your database using PHP objects rather than writing raw SQL queries.
database is done with two primary object 
   ->repositories or table Object 
   ->Entities 

=======================================
Database Basics
The easiest way to create a database connection is using a DSN string
Running Select Statements = run Select Statement
Running Insert Statements = insert recode
Running Update Statements = update recode
Running Delete Statements = delete the recode
Configuration = create own Configuration 

✅ Basic Required Settings:
| Key         | What It Means                                                            |
| ----------- | ------------------------------------------------------------------------ |
| `className` | The core class handling database connections (default is fine).          |
| `driver`    | The database type you're using. Examples: `Mysql`, `Sqlite`, `Postgres`. |
| `host`      | Hostname where the DB server is running. Usually `localhost`.            |
| `username`  | Your DB username. Example: `root`.                                       |
| `password`  | The password for that username.                                          |
| `database`  | The name of the database you are connecting to.                          |

🎛 Optional but Useful Settings:
| Key           | Use Case                                                                                    |
| ------------- | ------------------------------------------------------------------------------------------- |
| `port`        | Custom DB port. Default is 3306 for MySQL. Set it only if you're using a non-standard port. |
| `encoding`    | Character set used. Example: `'utf8mb4'` (good for emojis).                                 |
| `timezone`    | Timezone to use for DB timestamps. Example: `'UTC'`.                                        |
| `persistent`  | Keeps connection open between requests. Good for performance, but not supported on MSSQL.   |
| `schema`      | For PostgreSQL: sets the schema to use.                                                     |
| `unix_socket` | Used instead of host if connecting via a Unix socket (MySQL/Postgres on some servers).      |

🔒 SSL Security Options (MySQL Only):
| Key        | Use For                      |
| ---------- | ---------------------------- |
| `ssl_key`  | Path to SSL key file         |
| `ssl_cert` | Path to SSL certificate file |
| `ssl_ca`   | Path to CA certificate file  |

⚙️ Other Helpful Settings:
| Key                | Description                                                               |
| ------------------ | ------------------------------------------------------------------------- |
| `init`             | Run SQL when connection starts. Example: `['SET time_zone = "+00:00"']`.  |
| `log`              | If `true`, logs all SQL queries (great for debugging).                    |
| `quoteIdentifiers` | Use this if you use special characters or reserved words in column names. |
| `flags`            | Extra PDO options. Mostly used for advanced configurations.               |
| `cacheMetadata`    | If `true`, speeds up performance by caching table metadata. Recommended!  |

🔸 SQLite-Specific Settings (Ignore if using MySQL/PostgreSQL):
| Key     | What It Does                             |
| ------- | ---------------------------------------- |
| `mask`  | Sets permissions for created SQLite file |
| `cache` | Sets SQLite caching behavior             |
| `mode`  | Sets access mode for SQLite (read/write) |

🧠 Naming Conventions (VERY IMPORTANT)
| Item          | Convention                                                 |
| ------------- | ---------------------------------------------------------- |
| Table names   | lowercase, plural, snake\_case → `blog_posts`              |
| Table classes | PascalCase, ends with `Table` → `BlogPostsTable`           |
| Controller    | PascalCase, ends with `Controller` → `BlogPostsController` |

==============================
Read and Write Connections refer to a database scaling technique that allows you to separate database read and write operations across different servers.

Managing Connections refers to the way you configure, retrieve, and use database connections in your application

Accessing Connections means retrieving a configured database connection to interact directly with the database—either to run raw SQL, perform inserts/updates/deletes, or execute custom queries outside of the ORM.

Creating Connections at Runtime means defining a new database connection dynamically (in code) rather than in the config/app.php or app_local.php configuration files.

Data Types system provides a way to abstract and standardize how different databases handle various column types
| Abstract Type    | Maps To (DB Equivalent)                              | Notes                           |
| ---------------- | ---------------------------------------------------- | ------------------------------- |
| `string`         | `VARCHAR`, or `NVARCHAR` in SQL Server               | Regular text                    |
| `char`           | `CHAR` or `NCHAR`                                    | Fixed-length text               |
| `text`           | `TEXT`, `CLOB`, etc.                                 | For long text                   |
| `uuid`           | `CHAR(36)` if native UUID not available              | Universally Unique ID           |
| `binaryuuid`     | `BINARY(16)` or native UUID                          | Compressed UUID                 |
| `nativeuuid`     | `UUID` for MariaDB/MySQL; alias for `uuid` otherwise | For native UUID support         |
| `integer`        | `INT`, `INTEGER`                                     | Whole numbers                   |
| `smallinteger`   | `SMALLINT`                                           | Smaller whole numbers           |
| `tinyinteger`    | `TINYINT(1)` in MySQL                                | Often used as boolean           |
| `biginteger`     | `BIGINT`                                             | Large whole numbers             |
| `float`          | `FLOAT` or `DOUBLE`                                  | Approximate values              |
| `decimal`        | `DECIMAL`, stored as `string` in PHP                 | Use for exact math (e.g. money) |
| `boolean`        | `BOOLEAN`, or `TINYINT(1)` in MySQL                  | True/false                      |
| `binary`         | `BLOB`, `BYTEA`                                      | Raw binary data                 |
| `date`           | `DATE`                                               | Returns `Cake\I18n\Date`        |
| `datetime`       | `DATETIME`, returns `Cake\I18n\FrozenTime`           | For full date & time            |
| `timestamp`      | `TIMESTAMP`                                          | With automatic update           |
| `time`           | `TIME`                                               | Time only                       |
| `json`           | `JSON`, or `TEXT` if not supported                   | Stores JSON data                |
| `enum`           | Enumerated string values                             | Must define allowed values      |
| `geometry`, etc. | Geospatial types                                     | For location data               |

DateTimeType is a core class that provides a way to handle DATETIME columns in your database using PHP's DateTimeImmutable and CakePHP's enhanced date/time features.

EnumType class allows you to map database columns to PHP Enums, making your code more type-safe, readable, and maintainable.

Geospatial Types refer to special database column types that store geographical or geometric data, such as coordinates and shapes.

custom types let you create your own logic for how data is stored in the database and how it's represented in PHP.

Connecting Custom Datatypes to Schema Reflection and Generation"
custom datatypes allow you to create your own logic for how specific database fields are:
   -> Converted from database to PHP (e.g. "456A>G" → array),
   -> Converted from PHP to database,
   -> Handled during schema generation (for migrations),
   -> Handled during schema reflection (for reading DB schemas).

Mapping Custom Datatypes to SQL Expressions means telling CakePHP how to interpret complex SQL column types (like MySQL POINT, JSON, GEOMETRY, etc.) in PHP and vice versa—especially when these values require custom logic to serialize/deserialize or to express in SQL queries.

Connection Classes represent database connections and provide the interface for executing queries, transactions, and schema management.

executing queries means interacting with the database using either the ORM (Object-Relational Mapping), Query Builder, or raw SQL execution.

transactions are used to ensure that a group of database operations are completed successfully as a unit.
============================================================
Query Builder 
https://chatgpt.com/c/6838032e-a6c0-8002-99dd-60b09a8fc836

Query Builder is a powerful, flexible, and secure way to build and execute SQL queries using a fluent, object-oriented API — without writing raw SQL.
| Function          | Description                       | Example                                  |
| ----------------- | --------------------------------- | ---------------------------------------- |
| `count()`         | Counts rows or fields             | `$q->func()->count('*')`                 |
| `sum()`           | Sums values in a column           | `$q->func()->sum('price')`               |
| `avg()`           | Averages values in a column       | `$q->func()->avg('rating')`              |
| `min()` / `max()` | Get min/max value in a column     | `$q->func()->min('created')`             |
| `concat()`        | Concatenates strings              | `$q->func()->concat([...])`              |
| `dateDiff()`      | Gets difference between two dates | `$q->func()->dateDiff([...])`            |
| `now()`           | Gets current date/time            | `$q->func()->now()`                      |
| `cast()`          | Casts column to a type            | `$q->func()->cast('price', 'DECIMAL')`   |
| `coalesce()`      | Returns first non-null expression | `$q->func()->coalesce(['col1', 'col2'])` |

queries are lazily evaluated. This is a performance optimization: CakePHP does not run the SQL immediately when you call find() or add conditions like ->where(), ->orderBy(), etc.
| **Feature**                            | **Purpose / Use**                                                 |
| -------------------------------------- | ----------------------------------------------------------------- |
| Query Builder                          | Builds SQL queries with a fluent, chainable API.                  |
| The SelectQuery Object                 | Represents a SELECT query with customizable methods.              |
| Selecting Rows From A Table            | Retrieves multiple rows using `find()` and conditions.            |
| Selecting A Single Row From A Table    | Gets one row using `first()` or unique constraints.               |
| Getting A List Of Values From A Column | Extracts values from a single column as a list.                   |
| ResultSet Is A Collection Object       | Supports collection methods like `map()` and `filter()`.          |
| Queries Are Lazily Evaluated           | Improves performance: queries run only when results are accessed. |
| Selecting Data                         | Specifies what data columns to fetch.                             |
| Selecting Specific Fields              | Limits columns to improve performance.                            |
| Using SQL Functions                    | Applies SQL functions like `COUNT()`, `NOW()` in expressions.     |
| Window-Only Functions                  | Uses window functions like `RANK()` and `ROW_NUMBER()`.           |
| Custom Functions                       | Allows defining custom SQL expressions.                           |
| Ordering Results                       | Sorts query results using `orderBy()`.                            |
| Limiting Results                       | Limits the number of returned rows.                               |
| Aggregates - Group and Having          | Groups rows and filters using `group()` and `having()`.           |
| Case Statements                        | Adds conditional logic with `case()` expressions.                 |
| Fetching Arrays Instead of Entities    | Returns plain arrays using `enableHydration(false)`.              |
| Adding Calculated Fields               | Adds computed/derived fields via expressions.                     |
| Advanced Conditions                    | Supports complex conditional logic.                               |
| Using Identifiers in Expressions       | Safely quotes field names using `identifier()`.                   |
| Collation                              | Sets collation for string comparisons.                            |
| Automatically Creating IN Clauses      | Converts arrays in `where()` into `IN (...)` SQL.                 |
| Automatic IS NULL Creation             | Converts `null` in `where()` to `IS NULL`.                        |
| Automatic IS NOT NULL Creation         | Converts `'IS NOT' => null` to `IS NOT NULL`.                     |
| Raw Expressions                        | Injects raw SQL fragments safely.                                 |
| Using Connection Roles                 | Uses DB roles (e.g., read/write) for execution.                   |
| Expression Conjunction                 | Combines expressions with logical `AND`/`OR`.                     |
| Tuple Comparison                       | Compares multiple fields as a group.                              |
| Getting Results                        | Executes queries and fetches results.                             |
| Returning the Total Count of Records   | Uses `count()` to get number of matching rows.                    |
| Caching Loaded Results                 | Caches results with `cache()` for reuse.                          |
| Loading Associations                   | Eager loads related data via `contain()`.                         |
| Passing Conditions to Contain          | Filters associated data using conditions in `contain()`.          |
| Sorting Contained Associations         | Sorts associated records using `sort()` in `contain()`.           |
| Filtering by Associated Data           | Filters results based on related table data using `matching()`.   |
| Using innerJoinWith                    | Performs `INNER JOIN` with associated models.                     |
| Using notMatching                      | Filters out records with specific associations.                   |
| Using leftJoinWith                     | Performs `LEFT JOIN` to include unmatched associations.           |
| Adding Joins                           | Manually adds joins using `join()`.                               |
| Inserting Data                         | Inserts new records using `newEntity()` and `save()`.             |
| Updating Data                          | Updates existing records using `patchEntity()` and `save()`.      |
| Deleting Data                          | Deletes rows via `delete()` or query builder.                     |
| SQL Injection Prevention               | Secures queries using prepared statements and binding.            |
| Binding values                         | Binds values safely using `bind()` or placeholders.               |
| More Complex Queries                   | Builds advanced queries with joins, conditions, and expressions.  |
| Unions                                 | Combines multiple queries using `union()`.                        |
| Intersections                          | Returns common results across queries using `intersect()`.        |
| Subqueries                             | Embeds queries within others for filtering or data extraction.    |
| Adding Locking Statements              | Locks rows with statements like `FOR UPDATE`.                     |
| Window Functions                       | Uses analytical SQL functions for row-based stats.                |
| Common Table Expressions               | Adds modular `WITH` clauses for complex queries.                  |
| Executing Complex Queries              | Runs advanced raw or structured SQL using the builder.            |

================================================================================
https://chatgpt.com/c/68398c7c-0cc4-8002-bf1d-c7081a8725a8
Table Objects :-  In CakePHP, **Table Objects** represent database tables. 
                  They provide a way to interact with table data using 
                  CakePHP's **ORM (Object-Relational Mapping)**.
 
Purpose of Table Objects :-  To handle **CRUD operations**, define 
                             **associations**, apply **validation**, 
                             and manage **business logic** related to 
                             specific database tables.
Event List
| **Event Name**        | **Purpose**                                   |
| --------------------- | --------------------------------------------- |
| **initialize**        | Setup table (associations, behaviors, config) |
| **beforeMarshal**     | Modify data before converting to entities     |
| **afterMarshal**      | Inspect/modify entities after marshaling      |
| **beforeFind**        | Modify query before fetching data             |
| **buildValidator**    | Define validation rules                       |
| **buildRules**        | Define application rules (e.g., foreign keys) |
| **beforeRules**       | Before rules are checked                      |
| **afterRules**        | After rules are checked                       |
| **beforeSave**        | Before saving entity (can cancel save)        |
| **afterSave**         | After saving, before commit                   |
| **afterSaveCommit**   | After save transaction committed              |
| **beforeDelete**      | Before deleting entity (can cancel delete)    |
| **afterDelete**       | After deleting, before commit                 |
| **afterDeleteCommit** | After delete transaction committed            |

| **Topic**                        | **Purpose**                                                                |
| -------------------------------- | -------------------------------------------------------------------------- |
| **Table Objects**                | Represent and interact with database tables using CakePHP ORM.             |
| **Basic Usage**                  | Perform CRUD, define associations, and apply table-specific logic.         |
| **Customizing the Entity Class** | Use a custom class to represent a table row with additional logic.         |
| **Getting Table Instances**      | Retrieve table objects via `TableLocator` to reuse and manage consistency. |
| **Lifecycle Callbacks**          | Hook into the ORM process at different stages of entity/table operations.  |
| **Event List**                   | List of events triggered during ORM operations for customization.          |
| **initialize**                   | Set up table config, associations, behaviors, and default settings.        |
| **beforeMarshal**                | Modify or validate raw input data before it's converted into an entity.    |
| **afterMarshal**                 | Modify or inspect entity after data has been marshaled.                    |
| **beforeFind**                   | Modify or conditionally handle queries before execution.                   |
| **buildValidator**               | Define validation rules for incoming data.                                 |
| **buildRules**                   | Define application-level integrity rules (e.g., unique checks).            |
| **beforeRules**                  | Called before checking rules, allows short-circuiting.                     |
| **afterRules**                   | Called after rule checking to inspect results.                             |
| **beforeSave**                   | Modify or validate entity before saving to DB.                             |
| **afterSave**                    | Perform actions after entity has been saved.                               |
| **afterSaveCommit**              | Triggered after DB commit; useful for side effects like notifications.     |
| **beforeDelete**                 | Inspect or block delete before it happens.                                 |
| **afterDelete**                  | Actions to perform after deletion of an entity.                            |
| **afterDeleteCommit**            | Called after delete transaction is committed.                              |
| **Stopping Table Events**        | Halt event execution or skip further processing during callbacks.          |
| **Callback priorities**          | Control execution order when multiple listeners are attached.              |
| **Behaviors**                    | Reusable logic or traits that can be attached to tables (e.g., Timestamp). |
| **Configuring Connections**      | Use a specific DB connection for a table.                                  |
| **Using the TableLocator**       | Access and manage all table instances.                                     |
| **Configuring Table Objects**    | Set options like entity class, table name, and connection.                 |
| **Flushing the Registry**        | Clear stored table instances from memory (reset TableLocator).             |
| **Configuring Namespace**        | Set custom namespace to locate your ORM classes (tables/entities).         |

==========================================
Entity represents a single row of data in a table and provides an object-oriented way to interact with that row, including data access, modification, validation, custom getters/setters, and mass assignment protection.

Accessor is a special method you define inside an Entity class to control how a field’s value is returned when it is accessed.

Mutator is a method that runs when a value is set on an entity field. It allows you to:
Modify, sanitize, or transform the data before it's saved.
Optionally, set related fields based on the value.

Virtual Fields are custom, computed fields that don’t exist in your database, but behave like normal properties on your entity objects.

entities track changes to their fields—this is often referred to as the "dirty state"

validation errors are attached directly to the entity object after you attempt to save or patch it. 

mass assignment protection system helps you secure your entities by controlling which fields can be populated in bulk 

when you create a new entity and pass data in bulk (mass assignment), by default mass assignment protection is enabled — meaning fields not allowed in the entity’s $_accessible property will be ignored for security.

| **Feature**             | **Purpose (Short)**                    |
| ----------------------- | -------------------------------------- |
| Entities                | Represent a DB row as an object.       |
| Creating Entity Classes | Define logic/structure for a row.      |
| Creating Entities       | Instantiate a new record.              |
| Accessing Entity Data   | Get/set field values.                  |
| Accessors               | Format data when reading.              |
| Mutators                | Format data before saving.             |
| Virtual Fields          | Create computed fields.                |
| Modified Check          | Check if a field changed.              |
| Validation Errors       | Get validation issues.                 |
| Mass Assignment         | Securely assign multiple fields.       |
| Avoid Mass Protection   | Allow all fields (use cautiously).     |
| Modify Guarded Fields   | Change allowed fields dynamically.     |
| Bypass Guarding         | Set fields directly even if protected. |
| Persisted Check         | Check if entity is new or loaded.      |
| Lazy Loading            | Load associations when accessed.       |
| Traits                  | Reuse code across entities.            |
| Convert to Array/JSON   | Output for APIs/frontends.             |
| Expose Virtual Fields   | Show computed fields in output.        |
| Hide Fields             | Hide sensitive data (e.g., password).  |
| Complex Types           | Store arrays/JSON in DB.               |
================================================================
https://chatgpt.com/c/683c29a7-6bf8-8002-bb55-9dabb1f0439c
| Relationship | Association Type | Description                                                         | Example                          |
| ------------ | ---------------- | ------------------------------------------------------------------- | -------------------------------- |
| One-to-One   | `hasOne`         | A record in one table is linked to one in another                   | A user has one profile           |
| One-to-Many  | `hasMany`        | A record in one table is linked to many in another                  | A user has many articles         |
| Many-to-One  | `belongsTo`      | Many records in a table link to one in another                      | Many articles belong to one user |
| Many-to-Many | `belongsToMany`  | Records in one table are linked to many in another (and vice versa) | Articles belong to many tags     |

associations (or relationships) define how tables (models) in your application are related to one another.

hasOne association defines a one-to-one relationship where your current table (the source) has one associated record in another table (the target).

belongsTo association is used when a table (source) belongs to another table (target).

hasMany association is used to model one-to-many relationships, where one record in a table can be related to multiple records in another table.

belongsToMany association is used to represent a many-to-many relationship between two tables.

belongsToMany association with the through option is used when you want more control over the join table in a many-to-many relationship—especially when: need to store extra fields (like grade, days_attended).

ORM allows you to customize how associated data is fetched using custom finders.

when defining associations between tables, CakePHP uses conventions to automatically determine 

once you have defined associations (like belongsTo, hasMany, belongsToMany, etc.) in your table classes, you can load associated data when retrieving records using eager loading.
| **Feature**                    | **Purpose (Short)**                                                       |
| ------------------------------ | ------------------------------------------------------------------------- |
| **HasOne Associations**        | Link one record in this table to **one** in another (1:1).                |
| **BelongsTo Associations**     | Link this table’s record to a parent in another (inverse of HasOne).      |
| **HasMany Associations**       | Link one record in this table to **many** in another (1\:N).              |
| **BelongsToMany Associations** | Link many records in this table to many in another (N\:N via join table). |
| `through` Option               | Use a **custom join table** entity for BelongsToMany.                     |
| Association Finders            | Use **custom finder methods** when fetching associated data.              |
| Association Conventions        | Defines naming and foreign key **naming rules** for associations.         |
| Loading Associations           | Fetch related data using `contain()` or lazy-loading.                     |

=============================================
https://chatgpt.com/c/683d2524-7264-8002-bd74-48817d72caff
retrieving data and result sets involves using the ORM (Object-Relational Mapping) to interact with the database in a clean, object-oriented way. This concept is mainly handled through Table classes, Query Builder, and Entity objects.

debugging queries and result sets requires special care because the ORM returns complex objects like Query, ResultSet, and Entity.
| Expression                         | Description                                | Shows Results? |
| ---------------------------------- | ------------------------------------------ | -------------- |
| `debug($query)`                    | Shows internal Query state and bindings    | ❌              |
| `sql($query)`                      | Shows final SQL string (requires DebugKit) | ❌              |
| `debug($query->all())`             | Shows ResultSet object (not contents)      | ❌              |
| `debug($query->toList())`          | Shows result records as array of entities  | ✅              |
| `debug(iterator_to_array($query))` | Forces result as array                     | ✅              |
| `debug(json_encode($query))`       | Pretty JSON-encoded result set             | ✅              |
| `debug($query->first())`           | Shows a single entity object               | ✅              |
| `debug((string)$query->first())`   | Entity as JSON string                      | ✅              |

getting a single entity by primary key means retrieving one specific row from a database table using its primary key (usually the id column). 

finders are methods used to retrieve data from the database using the Query Builder.They allow you to write clean, reusable, and powerful queries when working with the ORM (Object-Relational Mapping).
| Finder Method       | Description                                |
| ------------------- | ------------------------------------------ |
| `find('all')`       | Gets all records (default)                 |
| `find('list')`      | Gets key-value pairs (e.g., for dropdowns) |
| `find('threaded')`  | Gets hierarchical data (e.g., comments)    |
| `find('neighbors')` | Gets previous and next records by ID       |
| `find('path')`      | Finds a path to a node in tree structures  |
| `find('bySlug')`    | Example of a **custom finder**             |

first() is a method used to fetch only the first row of a query result. It's commonly used when you expect just one result from a query (not multiple).

count() method is used to retrieve the number of records that match a query. It is useful when you want to know how many rows exist without actually loading all the data.

Finding Key/Value Pairs using the find('list') method allows you to retrieve an associative array from your database table, where:
The keys are identifiers (e.g., IDs, slugs),
The values are labels (e.g., titles, names),
The result is ideal for use in <select> dropdowns, JSON responses, etc.

Customize Key-Value Output in find('list') lets you generate dynamic labels and keys for dropdowns or associative arrays using virtual fields, accessors, or callback functions. 

find('threaded') is a powerful built-in finder that retrieves hierarchical (nested) data from a table where records are stored in an adjacency list format—typically using a parent_id column.

Custom Finder Methods in CakePHP 5 are a way to encapsulate reusable and complex query logic directly in your table classess

Dynamic Finders are a convenient shortcut in CakePHP's ORM that let you query your database using method names built from your table's fields, without writing explicit where() conditions.
