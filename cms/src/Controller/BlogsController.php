<?php
declare(strict_types=1);

namespace App\Controller;
use Cake\Datasource\ConnectionManager;
use Cake\ORM\Locator\LocatorAwareTrait;
use Cake\ORM\Query;
use Cake\Database\Expression\QueryExpression;
use Cake\ORM\TableRegistry;
use Cake\ORM\Query\SelectQuery;
// use Cake\Collection\CollectionInterface;
// use Cake\I18n\FrozenTime;


/**
 * Blogs Controller
 *
 * @property \App\Model\Table\BlogsTable $Blogs
 */
class BlogsController extends AppController
{
    use LocatorAwareTrait;
    /**
     * Index method
     *
     * @return \Cake\Http\Response|null|void Renders view
     */
    // public function index()
    // {
    //     $query = $this->Blogs->find();
    //     $blogs = $this->paginate($query);

    //     $this->set(compact('blogs'));
    // }

    // ---------------------------
    // public function index()
    // {
    //     $blogsTable = $this->fetchTable('Blogs');
    //     $query = $blogsTable->find()
    //         ->order(['Blogs.created' => 'DESC']); 
    //     $blogs = $this->paginate($query);
    //     $this->set(compact('blogs'));
    // }

    // ----------------Running Select Statements ------------------
    // public function index()
    // {
    //     // Get the predefined connection
    //     $connection = ConnectionManager::get('dynamic');

    //     // Raw query using the dynamic connection
    //     $results = $connection
    //         ->execute('SELECT * FROM blogs WHERE id = :id', ['id' => 1])
    //         ->fetchAll('assoc');
    //     // dd($results); // Optional: only for debugging

    //     // Still use the default ORM for paginated data
    //     $blogsTable = $this->fetchTable('Blogs');
    //     $blogs = $this->paginate($blogsTable->find());
    //     $this->set(compact('blogs'));
    // }

    // ------------------Running Insert Statements----------------
    public function addRaw()
    {
        $connection = ConnectionManager::get('dynamic');
        $data = [
            'title' => 'A Raw Inserted Blog',
            'content' => 'Lorem',
            'author' => 'Lorem',
            'created' => new \DateTime('now'),
            'modified' => new \DateTime('now'),
        ];
        // Insert using raw connection
        $success = $connection->insert('blogs', $data, [
            'created' => 'datetime',
            'modified' => 'datetime'
        ]);
        dd($success);
    }

    // ------------------Running Update Statements-------------------------
    public function updateRaw()
    {
        $connection = ConnectionManager::get('dynamic');

        // Update title of the blog with id = 1
        $success = $connection->update('blogs', ['title' => 'Updated Title'], ['id' => 5]);

        // Dump and die to check result
        dd($success);
    }

    // ----------------------Running Delete Statements--------------------
    public function deleteRaw()
    {
        $connection = ConnectionManager::get('dynamic');

        // Delete the blog where id = 1
        $success = $connection->delete('blogs', ['id' => 4]);

        // Dump and die to view the result
        dd($success);
    }

    //-------------------------- Query Builder--------------------------
    // public function index()
    // {
    //     // Using LocatorAwareTrait to fetch the table instance manually
    //     $blogsTable = $this->fetchTable('Blogs'); // equivalent to $this->Blogs

    //     // Start a new SelectQuery object
    //     $query = $blogsTable->find();

    //     // Customize the query if needed
    //     $query->select(['id', 'title', 'content', 'author', 'created', 'modified', 'mutation']);

    //     // Execute the query and fetch results
    //     $blogs = $query->all()->toArray();

    //     // Dump and die for debugging
    //     dd($blogs);
    // }

    // ---------------Selecting Rows From A Table--------------
    public function index()
    {
        // Use LocatorAwareTrait to get the Blogs table manually
        $blogsTable = $this->fetchTable('Blogs');

        // Basic query
        $query = $blogsTable->find();

        // Example 1: Simple foreach loop using all()
        foreach ($query->all() as $blog) {
            debug($blog->content); // Outputs each blog title
        }

        // Example 2: Using chained query with where, select, orderBy
        // $query2 = $blogsTable
        //     ->find()
        //     ->select(['id', 'title', 'created'])
        //     ->where(['id !=' => 1])
        //     ->orderBy(['created' => 'DESC']);

        // foreach ($query2->all() as $blog) {
        //     debug($blog->created);
        // }

        // Example 3: View SQL generated by query
        // debug($blogsTable->find()->where(['id' => 1]));

        // Example 4: Execute query and convert to list
        // $resultsIteratorObject = $blogsTable
        //     ->find()
        //     ->where(['id >' => 1])
        //     ->all();

        // foreach ($resultsIteratorObject as $blog) {
        //     debug($blog->id);
        // }

        $resultsArray = $blogsTable
            ->find()
            ->where(['id >' => 1])
            ->all()
            ->toList();

        // foreach ($resultsArray as $blog) {
        //     debug($blog->id);
        // }

        // Debug first result's title if exists
        // if (!empty($resultsArray)) {
        //     debug($resultsArray[0]->title);
        // }

        // Use dd() to stop and dump
        dd($resultsArray);
    }
    // -----------Selecting A Single Row From A Table---------------
    public function singleBlog()
    {
        $blogsTable = $this->fetchTable('Blogs');

        // Fetch one blog with id = 1
        $blog = $blogsTable
            ->find()
            ->where(['id' => 2])
            ->first();

        if ($blog) {
            debug($blog->title);
        } else {
            debug('No blog found with ID = 2');
        }

        dd($blog);
    }

    // --------------Getting a List of Values From a Column----------
    public function getTitleList()
    {
        $blogsTable = $this->fetchTable('Blogs');

        // Returns [id => title]
        $list = $blogsTable->find('list')->all();

        dd($list); // Will dump and exit
    }

    // -------------ResultSet Is A Collection Object-----------
    public function resultSetCollection()
    {
        $blogs = $this->fetchTable('Blogs');

        // Basic example using combine()
        $keyValueList = $blogs->find()->all()->combine('id', 'title');

        // Advanced example using map() and combine()
        $results = $blogs->find()
            ->where(['id >' => 1])
            ->orderBy(['title' => 'DESC'])
            ->all()
            ->map(function ($row) {
                $row->trimmedTitle = trim($row->title);
                return $row;
            })
            ->combine('id', 'trimmedTitle') // id => trimmed title
            ->toArray(); // Convert to array

        dd($results); // Dump and die (CakePHP debug)
    }

    // -------------------- Selecting Data Examples ---------------------
    public function selectExample()
    {
        $blogsTable = $this->fetchTable('Blogs');

        // Example 1: Selecting specific columns
        // $query1 = $blogsTable->find()
        //     ->select(['id', 'title', 'author']);

        // debug('Example 1: Selecting id, title, author');
        // foreach ($query1->all() as $blog) {
        //     debug($blog->title);
        // }

        // Example 2: Aliasing selected columns
        $query2 = $blogsTable->find()
            ->select([
                'blog_id' => 'id',
                'blog_title' => 'title',
                'written_by' => 'author'
            ]);

        debug('Example 2: Aliased fields');
        foreach ($query2->all() as $blog) {
            debug("{$blog->blog_id}: {$blog->blog_title} by {$blog->written_by}");
        }

        // Example 3: Selecting distinct values (e.g., unique authors)
        // $query3 = $blogsTable->find()
        //     ->select(['author'])
        //     ->distinct(['author']);

        // debug('Example 3: Distinct authors');
        // foreach ($query3->all() as $row) {
        //     debug($row->author);
        // }

        // Example 4: Basic WHERE conditions (combined with AND)
        // $query4 = $blogsTable->find()
        //     ->where(['author' => 'Lorem', 'title LIKE' => '%Raw%']);

        // debug('Example 4: WHERE with AND conditions');
        // foreach ($query4->all() as $blog) {
        //     debug("{$blog->id}: {$blog->title}");
        // }

        // Example 5: Multiple where() calls (equivalent to AND)
        // $query5 = $blogsTable->find()
        //     ->where(['author' => 'Lorem'])
        //     ->where(['title LIKE' => '%Updated%']);

        // debug('Example 5: Multiple where() calls');
        // foreach ($query5->all() as $blog) {
        //     debug("{$blog->id}: {$blog->title}");
        // }

        // Example 6: Using a callback with where() for advanced expressions
        $query6 = $blogsTable->find()
            ->where(function (\Cake\Database\Expression\QueryExpression $exp, \Cake\ORM\Query\SelectQuery $q) {
                return $exp
                    ->eq('author', 'Lorem')
                    ->gte('id', 1);
            });

        debug('Example 6: Callback expression in where()');
        foreach ($query6->all() as $blog) {
            debug("{$blog->id}: {$blog->title}");
        }

        // Optional: Convert last query to array and dump
        dd($query6->all()->toArray());
    }

    //-------------- Selecting Specific Fields----------------
    public function selectExamples()
    {
        $blogsTable = $this->fetchTable('Blogs');

        // 1. Select specific fields: id and title
        // $query1 = $blogsTable->find()
        //     ->select(['id', 'title']);
        // debug('Select only id and title');
        // foreach ($query1->all() as $blog) {
        //     debug($blog->id . ' - ' . $blog->title);
        // }

        // 2. Select all fields + a computed "slug" field (title-id)
        // $query2 = $blogsTable->find();
        // $query2
        //     ->select([
        //         'slug' => $query2->func()->concat([
        //             'title' => 'identifier',
        //             "'-'" => 'literal',
        //             'id' => 'identifier'
        //         ])
        //     ])
        //     ->select($blogsTable); // Select all fields from blogs
        // debug('Select all fields + slug');
        // foreach ($query2->all() as $blog) {
        //     debug($blog->slug);
        // }

        // 3. Use selectAlso to add additional field like count
        $query3 = $blogsTable->find();
        $query3->selectAllExcept($blogsTable, []); // Select all fields
        $query3->selectAlso(['row_count' => $query3->func()->count('*')]);
        debug('Select all fields + row_count');
        foreach ($query3->all() as $blog) {
            dd($blog->row_count);
        }

        // 4. Select all fields except the "author" field
        $query4 = $blogsTable->find();
        $query4->selectAllExcept($blogsTable, ['author']);
        debug('Select all except author');
        foreach ($query4->all() as $blog) {
            debug($blog); // author field will be excluded
        }

        // End with die-dump to prevent rendering view
        dd('Select examples completed.');
    }

    // -------------Window-Only Functions--------
    public function window()
    {
        $blogsTable = TableRegistry::getTableLocator()->get('Blogs');

        $query = $blogsTable->find()
            ->leftJoinWith('Categories');

        // ROW_NUMBER() window function expression
        $rowNumberExpression = $query->newExpr()->add('ROW_NUMBER() OVER (ORDER BY Blogs.created DESC)');

        $query->select([
            'row_num' => $rowNumberExpression,
            'Blogs.id',
            'Blogs.title',
            'Blogs.content',
            'Blogs.author',
            'Categories.name',
            'Categories.description',
        ]);

        // Convert result to array to see output
        $results = $query->toArray();

        debug($results);
        die();

        $this->set(compact('results'));
    }

    // ------------Custom Functions -----------
    public function getCustomDateFunctions($query, string $dateField = 'created')
    {
        // YEAR(created)
        $year = $query->func()->year([
            $dateField => 'identifier'
        ]);

        // DATE_FORMAT(created, '%H:%i')
        $time = $query->func()->date_format([
            $dateField => 'identifier',
            "'%H:%i'" => 'literal'
        ]);

        return [
            'yearCreated' => $year,
            'timeCreated' => $time,
        ];
    }
    public function someAction()
    {
        $blogsTable = $this->getTableLocator()->get('Blogs');

        $query = $blogsTable->find();

        $customDates = $this->getCustomDateFunctions($query, 'Blogs.created');

        $query->select([
            'Blogs.id',
            'Blogs.title',
            'Blogs.created',
            'Blogs.category_id',
        ] + $customDates);

        $results = $query->first();

        dd($results); // dump and die the results
    }

    // ---------------------Ordering Results-------
    public function demonstrateOrdering()
    {
        $blogsTable = $this->getTableLocator()->get('Blogs');

        // 1) Order by multiple columns (appends ORDER BY clauses)
        $query = $blogsTable->find();
        $query->orderBy(['title' => 'ASC', 'id' => 'ASC']);
        $results1 = $query->all();

        // 2) Overwrite ORDER BY with a new clause
        $query2 = $blogsTable->find();
        $query2->orderBy(['created' => 'DESC'], Query::OVERWRITE);
        $results2 = $query2->all();

        // 3) Use orderByAsc() for complex expression (concat title and author)
        $query3 = $blogsTable->find();
        $concat = $query3->func()->concat([
            'title' => 'identifier',
            ' - ',
            'author' => 'identifier'
        ]);
        $query3->orderByAsc($concat);
        $results3 = $query3->all();

        // 4) Use Closure for complex ordering logic (CASE expression example)
        $query4 = $blogsTable->find();
        $query4->orderByAsc(function (QueryExpression $exp, Query $query) {
            $caseExpr = $query->newExpr()->case()
                ->when(['author' => 'John'])
                ->then(1)
                ->when(['author' => 'Jane'])
                ->then(2)
                ->else(3);
            return $exp->add($caseExpr);
        });
        $results4 = $query4->all();

        dd([
            'Order by title & id ASC' => $results1,
            'Overwrite order by created DESC' => $results2,
            'Order by concat(title, author) ASC' => $results3,
            'Order by CASE expression ASC' => $results4,
        ]);
    }

    // ------------Aggregates - Group and Having-----------------------
    public function blogStats(): void
    {
        $blogs = $this->fetchTable('Blogs');

        $query = $blogs->find();
        
        $query->select([
            'author',
            'total_blogs' => $query->func()->count('id'),
            'latest_post' => $query->func()->max('created')
        ])
        ->group('author');
        // ->having(function ($exp, $q) {
        //     return $exp->gt('total_blogs', 1);
        // });

        $results = $query->all();

        foreach ($results as $row) {
            debug($row->toArray());
        }

        dd($results);
    }

    // ----------Case Statements------------------
    public function case(): void
    {
        $blogs = $this->fetchTable('Blogs');
        $query = $blogs->find();

        $mutationPublished = $query->newExpr()
            ->case()
            ->when(['mutation' => 'published']) // or whatever value you use
            ->then(1)
            ->else(null);

        $mutationUnpublished = $query->newExpr()
            ->case()
            ->when(['mutation' => 'unpublished'])
            ->then(1)
            ->else(null);

        $query->select([
            'number_published' => $query->func()->count($mutationPublished),
            'number_unpublished' => $query->func()->count($mutationUnpublished)
        ]);

        $result = $query->first();

        if ($result) {
            debug("Published: {$result->number_published}, Unpublished: {$result->number_unpublished}");
        }

        dd($result);
    }
    public function caseSizingExampleBlogs()
    {
        $blogs = $this->fetchTable('Blogs');
        $query = $blogs->find();

        // Build LENGTH(content) expression
        $lengthExpr = $query->func()->length(['content' => 'literal']);

        // Build CASE expression for size classification
        $sizing = $query->newExpr()->case()
            ->when(
                $query->newExpr()->lt($lengthExpr, 300)
            )->then('SHORT')
            ->when(
                $query->newExpr()->between($lengthExpr, 300, 500)
            )->then('MEDIUM')
            ->when(
                $query->newExpr()->gte($lengthExpr, 501)
            )->then('LONG');

        // Select desired fields including the CASE result
        $query = $query->select([
            'id',
            'title',
            'author',
            'created',
            'modified',
            'category_id',
            'size' => $sizing
        ])->limit(10);

        $results = $query->all();

        // Output the results
        foreach ($results as $blog) {
            echo "Blog ID: {$blog->id} | Title: {$blog->title} | Size: {$blog->size}\n";
        }
    }

    // ----------Fetching Arrays Instead of Entities--------
    public function fetchBlogsAsArray()
    {
        $blogs = $this->fetchTable('Blogs');
        $query = $blogs->find();
        $query->enableHydration(false); // Disable entity hydration to get arrays

        $results = $query->toArray(); // Execute and get the result as an array

        dd($results); // Dump and die the result for debugging
    }

    // --------------Adding Calculated Fields----------------
    public function formattedBlogs()
    {
        $blogs = $this->fetchTable('Blogs');

        $query = $blogs->find()
            ->select(['id', 'title', 'created'])
            ->formatResults(function (\Cake\Collection\CollectionInterface $results) {
                return $results->map(function ($row) {
                    // Calculate days since blog was created
                    $row['days_old'] = $row->created->diff(new \DateTime())->days;
                    return $row;
                });
            });

        $results = $query->all();

        // Use dd to dump the results and stop execution
        dd($results);
    }

    // ------------------Advanced Conditions--------------------
    // 1. Simple OR condition
    public function simpleOrCondition()
    {
        $query = $this->fetchTable('Blogs')->find()
            ->where([
                'author' => 'Lorem',
                'OR' => [['title' => 'Updated Title']]
            ]);
        dd($query->all());
    }

    // 2. Callback-based complex condition
    public function callbackWhere()
    {
        $query = $this->fetchTable('Blogs')->find()
            ->where(function (QueryExpression $exp, SelectQuery $query) {
                // OR condition for author
                $authorExpr = $query->newExpr()
                    ->or(['author' => 'Elvis Bolton'])
                    ->add(['author' => 'Glenna Horton']);

                // AND condition for structured mutation + category
                $publishedExpr = $query->newExpr()
                    ->and(['mutation IS' => null, 'category_id' => 1]);

                return $exp->or([
                    ['mutation IS NOT' => null], // any JSON-mutation defined
                    $query->newExpr()->and([$authorExpr, $publishedExpr])
                ]);
            });
        dd($query->all());
    }

    // 3. Basic combinators: eq, notEq, gt
    public function basicCombinators()
    {
        $query = $this->fetchTable('Blogs')->find()
            ->where(function (QueryExpression $exp) {
                return $exp
                    ->eq('author', 'Elvis Bolton')
                    ->notEq('category_id', 3)
                    ->gt('id', 5);
            });
        dd($query->all());
    }

    // 4. Mixed AND/OR conditions
    public function andOrMix()
    {
        $query = $this->fetchTable('Blogs')->find()
            ->where(function (QueryExpression $exp) {
                $orAuthors = $exp->or([
                    'author' => 'Rajah Graves',
                    'author' => 'Orlando Leach'
                ]);

                return $exp
                    ->add($orAuthors)
                    ->gte('id', 2)
                    ->isNull('mutation'); // since most sample entries had mutation = NULL
            });
        dd($query->all());
    }

    // 5. NOT expression
    public function notExpression()
    {
        $query = $this->fetchTable('Blogs')->find()
            ->where(function (QueryExpression $exp) {
                $orConditions = $exp->or([
                    'author' => 'Rajah Graves',
                    'author' => 'Elvis Bolton'
                ]);

                return $exp
                    ->not($orConditions)
                    ->lte('id', 10);
            });
        dd($query->all());
    }


    // 6. Using SQL functions
    public function useSqlFunction()
    {
        $query = $this->fetchTable('Blogs')->find()
            ->where(function (QueryExpression $exp, SelectQuery $q) {
                $year = $q->func()->year(['created' => 'identifier']);

                return $exp
                    ->gte($year, 2020)
                    ->isNotNull('mutation'); // using actual available data
            });
        dd($query->all());
    }


    // 7. LIKE condition
    public function likeCondition()
    {
        $query = $this->fetchTable('Blogs')->find()
            ->where(function (QueryExpression $exp) {
                return $exp->like('title', '%Qui%');
            });
        dd($query->all());
    }


    // 8. IN condition
    public function inCondition()
    {
        $query = $this->fetchTable('Blogs')->find()
            ->where(function (QueryExpression $exp) {
                return $exp->in('category_id', [1, 2, 3]);
            });
        dd($query->all());
    }


    // 9. BETWEEN condition
    public function betweenCondition()
    {
        $query = $this->fetchTable('Blogs')->find()
            ->where(function (QueryExpression $exp) {
                return $exp->between('id', 8, 15);
            });
        dd($query->all());
    }

    // 10. EXISTS subquery
    public function existsSubquery()
    {
        // Subquery to check for categories named 'Technology'
        $subquery = $this->fetchTable('Categories')->find()
            ->select(['id'])
            ->where(function (QueryExpression $exp, SelectQuery $q) {
                // Match category id with blogs.category_id
                return $exp->equalFields('Categories.id', 'Blogs.category_id');
            })
            ->andWhere(['Categories.name' => 'Technology']);

        // Main query selecting Blogs where the subquery exists
        $query = $this->fetchTable('Blogs')->find()
            ->where(function (QueryExpression $exp, SelectQuery $q) use ($subquery) {
                return $exp->exists($subquery);
            });

        // Debug SQL and results
        debug($query->sql());
        dd($query->all());
    }


    // 11. NOT EXISTS subquery
    public function notExistsSubquery()
    {
        $subquery = $this->fetchTable('Categories')->find()
            ->select(['id'])
            ->where(function (QueryExpression $exp, SelectQuery $q) {
                return $exp->equalFields('Categories.id', 'Blogs.category_id');
            })
            ->andWhere(['Categories.name' => 'Technology']);

        $query = $this->fetchTable('Blogs')->find()
            ->where(function (QueryExpression $exp, SelectQuery $q) use ($subquery) {
                return $exp->notExists($subquery);
            });

        dd($query->all());
    }


    // 12. Bound parameters
    public function boundParameters()
    {
        $query = $this->fetchTable('Blogs')->find()
            ->where(['created BETWEEN :start AND :end'])
            ->bind(':start', '2025-05-01', 'date')
            ->bind(':end', '2025-05-31', 'date');

        dd($query->all());
    }

    // 13. Raw field comparison
    public function rawFieldComparison()
    {
        $query = $this->fetchTable('Blogs')->find()
            ->leftJoin(
                ['Categories' => 'categories'],
                ['Blogs.category_id = Categories.id']
            )
            ->where(['Categories.id IS' => null]); // No matching category

        dd($query->all());
    }









    /**
     * View method
     *
     * @param string|null $id Blog id.
     * @return \Cake\Http\Response|null|void Renders view
     * @throws \Cake\Datasource\Exception\RecordNotFoundException When record not found.
     */
    public function view($id = null)
    {
        $blog = $this->Blogs->get($id, contain: ['Posts']);
        $this->set(compact('blog'));
    }

    /**
     * Add method
     *
     * @return \Cake\Http\Response|null|void Redirects on successful add, renders view otherwise.
     */
    // public function add()
    // {
    //     $blog = $this->Blogs->newEmptyEntity();
    //     if ($this->request->is('post')) {
    //         $blog = $this->Blogs->patchEntity($blog, $this->request->getData());
    //         if ($this->Blogs->save($blog)) {
    //             $this->Flash->success(__('The blog has been saved.'));

    //             return $this->redirect(['action' => 'index']);
    //         }
    //         $this->Flash->error(__('The blog could not be saved. Please, try again.'));
    //     }
    //     $this->set(compact('blog'));
    // }
    public function add()
{
    $blog = $this->Blogs->newEmptyEntity();
    if ($this->request->is('post')) {
        $blog = $this->Blogs->patchEntity($blog, $this->request->getData());

        // Add mutation data here (example)
        $blog->mutation = ['x' => 100, 'y' => 200];

        if ($this->Blogs->save($blog)) {
            $this->Flash->success(__('The blog has been saved.'));

            return $this->redirect(['action' => 'index']);
        }
        $this->Flash->error(__('The blog could not be saved. Please, try again.'));
    }
    $this->set(compact('blog'));
}


    /**
     * Edit method
     *
     * @param string|null $id Blog id.
     * @return \Cake\Http\Response|null|void Redirects on successful edit, renders view otherwise.
     * @throws \Cake\Datasource\Exception\RecordNotFoundException When record not found.
     */
    public function edit($id = null)
    {
        $blog = $this->Blogs->get($id, contain: []);
        if ($this->request->is(['patch', 'post', 'put'])) {
            $blog = $this->Blogs->patchEntity($blog, $this->request->getData());
            if ($this->Blogs->save($blog)) {
                $this->Flash->success(__('The blog has been saved.'));

                return $this->redirect(['action' => 'index']);
            }
            $this->Flash->error(__('The blog could not be saved. Please, try again.'));
        }
        $this->set(compact('blog'));
    }

    /**
     * Delete method
     *
     * @param string|null $id Blog id.
     * @return \Cake\Http\Response|null Redirects to index.
     * @throws \Cake\Datasource\Exception\RecordNotFoundException When record not found.
     */
    public function delete($id = null)
    {
        $this->request->allowMethod(['post', 'delete']);
        $blog = $this->Blogs->get($id);
        if ($this->Blogs->delete($blog)) {
            $this->Flash->success(__('The blog has been deleted.'));
        } else {
            $this->Flash->error(__('The blog could not be deleted. Please, try again.'));
        }

        return $this->redirect(['action' => 'index']);
    }
}
